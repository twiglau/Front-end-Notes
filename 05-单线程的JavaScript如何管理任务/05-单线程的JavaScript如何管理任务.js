/**
 * 如果说JavaScript代码运行过程中的 语法分析阶段,编译阶段和执行阶段属于微观
 * 层面的运行逻辑.
 * 那么今天来介绍下宏观角度下的JavaScript运行过程,包括JavaScript的单线程设计,
 * 事件循环的并发模型设计.
 * 
 * 该怎么理解JavaScript是单线程? 从浏览器说起
 * 
 * 这样一个单线程的JavaScript,意味着任务需要一个接一个地处理,如果有一个任务时等待
 * 用户输入,那在用户进行操作前,所有其他任务都处于等待状态,页面会进入假死状态,用户体验
 * 会很糟糕.
 * 
 * 那么,为了高效进行页面的交互和渲染处理,我们围绕着任务是否阻塞JavaScript主线程,将JavaScript
 * 中的任务分为同步任务和异步任务.
 */

/**
 * 一, 同步任务和异步任务
 * > 同步任务: 在主线程上排队执行的任务,前一个任务完整地执行完成后,后一个任务才会被执行.
 * > 异步任务: 不会阻塞主线程,在其任务执行完成之后,会再根据一定的规则去执行相关的回调.
 */

/**
 * 二, 同步任务与函数调用栈
 * 在JavaScript中,同步任务基本上可以认为是执行JavaScript代码. 在上一讲内容中,我们提到JavaScript
 * 在执行过程中每进入一个不同的运行环境时,都会创建一个相应的执行上下文. 那么,当我们执行一段JavaScript
 * 代码时,通常会创建多个执行上下文.
 * 
 * 而JavaScript解释器会以栈的方式管理这些执行上下文,以及函数之间的调用关系,形成函数调用栈(call stack)
 * (调用栈可理解为一个存储函数调用的栈结构,遵循FILO(先进后出) 的原则).
 * 
 * 我们来看一下JavaScript中代码执行的过程:
 * > 1. 首先进入全局环境,全局执行上下文被创建并添加进栈中;
 * > 2. 每调用一个函数,该函数执行上下文会被添加进调用栈,并开始执行;
 * > 3. 如果正则调用栈中执行的A函数还调用了B函数,那么B函数也将会被添加进调用栈;
 * > 4. 一旦B函数被调用,便会立即执行;
 * > 5. 当前函数执行完毕后,JavaScript解释器将其清出调用栈,继续执行当前执行环境下的剩余的代码.
 * 
 * 由此可见,JavaScript代码执行过程中.
 * 函数调用栈栈底永远是全局执行上下文,栈顶永远是当前执行上下文.
 * 
 * 在不考虑全局执行上下文时,我们可以理解为刚开始的时候调用栈是空的,每当有函数被调用,相应的执行上下文都会
 * 被添加到调用栈中. 执行完函数中相关代码后,该执行上下文又会自动被调用栈移除,最后调用又回到了空的状态
 * (同样不考虑全局执行上下文).
 * 
 * 由于栈的容量是有限制的,所以当我们没有合理调用函数的时候,可能会导致爆栈异常,此时控制台便会抛出错误:
 * 
 * 如图 05.1 示例图
 * 
 * 这样的一个函数调用栈结构,可以理解为JavaScript中同步任务的执行环境,同步任务也可以理解为JavaScript代码
 * 片段的执行.
 * 
 * 同步任务的执行阻塞主线程,也就是说,一个函数执行的时候不会被抢占, 只有在它执行完毕之后,才会去执行任何其他的
 * 代码.
 * 这意味着如果我们一个任务执行的时间过长,浏览器就无法处理与用户的交互,例如点击或滚动.
 * 
 * 因此,我们还需要用到异步任务.
 */

/**
 * 二, 异步任务与回调队列
 * 异步任务包括一些需要等待响应的任务,包括用户交互,HTTP请求,定时器等.
 * 
 * 我们知道,I/O类型的任务会有较长的等待时间,对于这类无法立刻得到结果的事件,可以使用异步任务的方式. 这个过程中
 * JavaScript线程就不用处于等待状态,CPU也可以处理其他任务.
 * 
 * 异步任务需要提供回调函数,当异步任务有了运行结果之后,该任务则会被添加到回调队列中,主线程在适当的时候会从回调
 * 队列中取出相应的回调函数并执行.
 * 
 * 这里提到的回调队列又是什么呢?
 * 实际上,JavaScript在运行的时候,除了函数调用栈之外,还包含了一个待处理的回调队列.在回调队列中的都是已经有了运行
 * 结果的异步任务,每一个异步任务都会关联着一个回调函数.
 * 
 * 回调队列则遵循FIFO(先进先出)的原则,JavaScript执行代码过程中,会进行以下的处理:
 * > 运行时,会从最先进入队列的任务开始,处理队列中的任务;
 * > 被处理的任务会被移除队列,该任务的运行结果会作为输入参数,并调用与之关联的函数,此时会产生一个函数调用栈;
 * > 函数会一直处理到调用栈再次为空,然后Event Loop将会处理队列中的下一个任务.
 * 
 * 这里我们提到了Event Loop, 它主要是用来管理单线程的JavaScript中同步任务和异步任务的执行问题.
 */

/**
 * 三,单线程的JavaScript是如何管理任务的
 * 我们知道,单线程的设计会存在阻塞问题,为此JavaScript中任务被分为同步和异步任务. 那么,同步任务和异步任务之间是按照
 * 什么顺序来执行的呢?
 * 
 * JavaScript有一个机遇时间循环的并发模型,称为时间循环(Event Loop),它的设计解决了同步任务和异步任务的管理问题.
 * 
 * 根据 JavaScript运行环境的不同,Event Loop 也会被分成浏览器的 Event Loop 和 Node.js中的 Event Loop
 */

/**
 * 四,浏览器的Event Loop
 * 在浏览器中,每当一个被监听的事件发生是,事件监听器绑定的相关任务就会被添加进回调队列. 通过事件产生的任务是异步任务,常见
 * 的事件任务包括:
 * > 用户交互事件产生的事件任务,比如输入操作;
 * > 计时器产生的事件任务,比如setTimeout;
 * > 异步请求产生的事件任务,比如HTTP请求.
 * 
 * JavaScript的运行过程,如下:
 * 
 * 如图 05.2 示例图
 * 
 * 如上,主线程运行的时候,会产生堆(heap) 和 栈(stack),其中堆为内存,栈为函数调用栈. 我们能看到,Event Loop负责执行代码,收集
 * 和处理事件以及执行队列中的子任务,具体包括以下过程:
 * 
 * > 1. JavaScript 有一个主线程和调用栈,所有的任务最重都会被放到调用栈等待主线程执行.
 * > 2. 同步任务会被放在调用栈中,暗战顺序等待主线程一次执行.
 * > 3. 主线程之外存在一个回调队列,回到队列中的异步任务最重会在主线程中以调用栈的方式运行.
 * > 4. 同步任务都在主线程上执行,栈中代码在执行的时候会调用浏览器的API,此时会产生一些异步任务.
 * > 5. 异步任务会在有了结果(比如被监听的事件发生时)后,将异步任务以及关联的回调函数放入回到对列中.
 * > 6. 调用栈中任务执行完毕后,此时主线程处于空间状态,会从回调队列中获取任务进行处理.
 */